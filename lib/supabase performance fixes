Summarize the issue and suggest fixes for the following lint item: Title: Auth RLS Initialization Plan Entity: public.profiles Schema: public Issue Details: Table public.profiles has a row level security policy Users can view their own profile that re-evaluates current_setting() or auth.() for each row. This produces suboptimal query performance at scale. Resolve the issue by replacing auth.<function>() with (select auth.<function>()). See docs for more info. Description: Detects if calls to current_setting() and auth.<function>() in RLS policies are being unnecessarily re-evaluated for each row




Reasoned
Issue summary
Table: public.profiles
Problem: The RLS policy "Users can view their own profile" calls current_setting() or an auth.<function>() (for example auth.uid() or auth.jwt()) directly inside the policy expression.
Root cause: Direct calls to these functions inside the WHERE/USING/WITH CHECK expressions are evaluated for every row, which harms performance at scale.
Recommended pattern: Call such functions once via a scalar subquery so Postgres treats them as a constant for the query, e.g. replace auth.uid() with (SELECT auth.uid()).
Why this matters
Without the SELECT wrapper, Postgres may re-evaluate the function per row during scans/joins, causing unnecessary overhead and slower queries on large tables.
Using a scalar subquery ensures the function is evaluated once per statement (or per plan) which improves query planning, caching, and throughput.
This is a Supabase-recommended best practice for RLS policies that reference auth-related functions.
Suggested fixes
Identify the problematic policy

Look for CREATE POLICY or existing policy on public.profiles that contains auth.uid(), auth.jwt(), or current_setting(...) in a USING or WITH CHECK clause.
Edit the policy expression to use a scalar subquery

Example — before: CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT TO authenticated USING (user_id = auth.uid());

After: CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT TO authenticated USING (user_id = (SELECT auth.uid()));

If using jwt claims, cast as needed. Example: USING (tenant_id = ((SELECT auth.jwt()) ->> 'tenant_id')::uuid);

For current_setting: USING (app_tenant = (SELECT current_setting('my.tenant', true)));

Apply equivalent changes for INSERT/UPDATE/WITH CHECK expressions

Ensure both USING and WITH CHECK use the scalar-subquery form where auth or current_setting is referenced.
Validate after change

Test as authenticated users to confirm access behavior is unchanged.
Run representative queries and check query plans (EXPLAIN ANALYZE) before and after to confirm reduced per-row calls.
Optional performance improvements

Add indexes on columns used in the policy (e.g., user_id, tenant_id).
If policy logic is complex, consider a SECURITY DEFINER helper function that returns the user/tenant once and is carefully permissioned (remember to revoke execute from anon/authenticated if appropriate).
Example replacement snippets
auth.uid(): USING (user_id = (SELECT auth.uid()));

auth.jwt() claims: USING (tenant_id = ( (SELECT auth.jwt()) ->> 'tenant_id')::uuid);

current_setting(): USING (env_tenant = (SELECT current_setting('my.tenant', true)));

Validation steps (1–2 lines)
Run queries as a normal user to confirm identical access results.
Use EXPLAIN ANALYZE to compare query plans before/after and verify the function is no longer being executed per row.
References
Supabase RLS guidance: call functions with SELECT to avoid per-row re-evaluation (see docs).


