import 'dart:io';
import 'package:dartz/dartz.dart';
import 'package:postgrest/postgrest.dart';
import 'package:papercraft/core/domain/errors/failures.dart';
import 'package:papercraft/core/domain/interfaces/i_logger.dart';
import 'package:papercraft/features/authentication/domain/services/user_state_service.dart';
import 'package:papercraft/features/student_management/data/datasources/student_remote_datasource.dart';
import 'package:papercraft/features/student_management/data/models/student_model.dart';
import 'package:papercraft/features/student_management/domain/entities/student_entity.dart';
import 'package:papercraft/features/student_management/domain/repositories/student_repository.dart';

/// Implementation of StudentRepository
/// Handles data layer operations for students
class StudentRepositoryImpl implements StudentRepository {
  final StudentRemoteDataSource remoteDataSource;
  final ILogger logger;
  final UserStateService userStateService;

  StudentRepositoryImpl({
    required this.remoteDataSource,
    required this.logger,
    required this.userStateService,
  });

  @override
  Future<Either<Failure, StudentEntity>> addStudent({
    required String gradeSectionId,
    required String rollNumber,
    required String fullName,
    String? email,
    String? phone,
  }) async {
    try {
      final tenantId = userStateService.currentTenantId;
      final academicYear = userStateService.currentAcademicYear;

      if (tenantId == null || tenantId.isEmpty) {
        return Left(PermissionFailure('Tenant ID not available'));
      }

      final student = StudentModel(
        id: '', // Will be generated by backend
        tenantId: tenantId as String,
        gradeSectionId: gradeSectionId,
        rollNumber: rollNumber,
        fullName: fullName,
        email: email,
        phone: phone,
        academicYear: academicYear,
        isActive: true,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final result = await remoteDataSource.addStudent(student);
      logger.info('Student added: $rollNumber - $fullName', category: LogCategory.system);
      return Right(result);
    } on PostgrestException catch (e) {
      if (e.message.contains('unique_student_per_grade_section')) {
        return Left(ValidationFailure('Student with roll number $rollNumber already exists in this section'));
      }
      logger.error('Postgres error adding student: ${e.message}', category: LogCategory.system);
      return Left(ServerFailure(e.message, code: e.code));
    } on SocketException catch (e) {
      logger.error('Network error adding student: ${e.message}', category: LogCategory.system);
      return Left(NetworkFailure('Network error: ${e.message}'));
    } catch (e) {
      logger.error('Error adding student: ${e.toString()}', category: LogCategory.system);
      return Left(CacheFailure('Failed to add student: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, List<StudentEntity>>> getStudentsByGradeSection(
    String gradeSectionId,
  ) async {
    try {
      final students = await remoteDataSource.getStudentsByGradeSection(gradeSectionId);
      logger.info('Fetched ${students.length} students for grade section', category: LogCategory.system);
      return Right(students.cast<StudentEntity>());
    } on SocketException catch (e) {
      logger.error('Network error fetching students: ${e.message}', category: LogCategory.system);
      return Left(NetworkFailure('Network error: ${e.message}'));
    } catch (e) {
      logger.error('Error fetching students: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to fetch students: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, StudentEntity>> getStudentById(String studentId) async {
    try {
      final student = await remoteDataSource.getStudentById(studentId);
      if (student == null) {
        return Left(NotFoundFailure('Student not found'));
      }
      return Right(student);
    } catch (e) {
      logger.error('Error fetching student: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to fetch student: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, List<StudentEntity>>> getActiveStudents() async {
    try {
      final students = await remoteDataSource.getAllActiveStudents();
      return Right(students.cast<StudentEntity>());
    } catch (e) {
      logger.error('Error fetching active students: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to fetch students: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, StudentEntity>> updateStudent(StudentEntity student) async {
    try {
      final model = StudentModel.fromEntity(student);
      final result = await remoteDataSource.updateStudent(model);
      logger.info('Student updated: ${student.rollNumber}', category: LogCategory.system);
      return Right(result);
    } on PostgrestException catch (e) {
      logger.error('Postgres error updating student: ${e.message}', category: LogCategory.system);
      return Left(ServerFailure(e.message, code: e.code));
    } catch (e) {
      logger.error('Error updating student: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to update student: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, void>> deleteStudent(String studentId) async {
    try {
      await remoteDataSource.deleteStudent(studentId);
      logger.info('Student deleted: $studentId', category: LogCategory.system);
      return const Right(null);
    } catch (e) {
      logger.error('Error deleting student: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to delete student: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, List<StudentEntity>>> bulkUploadStudents({
    required String gradeSectionId,
    required List<Map<String, String>> studentData,
  }) async {
    try {
      print('[DEBUG REPO] bulkUploadStudents called with ${studentData.length} students');
      final tenantId = userStateService.currentTenantId;
      final academicYear = userStateService.currentAcademicYear;

      if (tenantId == null || tenantId.isEmpty) {
        print('[DEBUG REPO] Tenant ID not available');
        return Left(PermissionFailure('Tenant ID not available'));
      }
      print('[DEBUG REPO] Tenant ID: $tenantId, Academic Year: $academicYear');

      final students = <StudentModel>[];
      final duplicates = <String>[];

      // Check for existing students
      for (final data in studentData) {
        final rollNumber = data['roll_number'] ?? '';
        if (rollNumber.isEmpty) continue;

        // Get the grade_section_id from the student data (each student has their own now)
        final studentGradeSectionId = data['grade_section_id'] ?? gradeSectionId;
        if (studentGradeSectionId.isEmpty) continue;

        final exists = await remoteDataSource.studentExists(
          gradeSectionId: studentGradeSectionId,
          rollNumber: rollNumber,
        );

        if (exists) {
          duplicates.add(rollNumber);
        } else {
          students.add(StudentModel(
            id: '', // Backend generated
            tenantId: tenantId as String,
            gradeSectionId: studentGradeSectionId,
            rollNumber: rollNumber,
            fullName: data['full_name'] ?? '',
            email: data['email'],
            phone: data['phone'],
            academicYear: academicYear,
            isActive: true,
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          ));
        }
      }

      if (students.isEmpty) {
        print('[DEBUG REPO] All students are duplicates or invalid');
        return Left(ValidationFailure('No new students to add. All records already exist.'));
      }

      print('[DEBUG REPO] Inserting ${students.length} students, ${duplicates.length} duplicates');
      final result = await remoteDataSource.bulkInsertStudents(students);
      print('[DEBUG REPO] Bulk insert completed: ${result.length} students inserted');
      logger.info('Bulk uploaded ${result.length} students, ${duplicates.length} duplicates skipped',
          category: LogCategory.system);

      return Right(result.cast<StudentEntity>());
    } on PostgrestException catch (e) {
      logger.error('Postgres error bulk uploading students: ${e.message}', category: LogCategory.system);
      return Left(ServerFailure(e.message, code: e.code));
    } catch (e) {
      logger.error('Error bulk uploading students: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to bulk upload students: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, bool>> studentExists({
    required String gradeSectionId,
    required String rollNumber,
  }) async {
    try {
      final exists = await remoteDataSource.studentExists(
        gradeSectionId: gradeSectionId,
        rollNumber: rollNumber,
      );
      return Right(exists);
    } catch (e) {
      logger.error('Error checking student existence: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to check student: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, int>> getStudentsCountByGradeSection(String gradeSectionId) async {
    try {
      final count = await remoteDataSource.getStudentCountByGradeSection(gradeSectionId);
      return Right(count);
    } catch (e) {
      logger.error('Error getting student count: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to get student count: ${e.toString()}'));
    }
  }

  @override
  Future<Either<Failure, List<StudentEntity>>> getStudentsWithPagination({
    required int page,
    required int pageSize,
    String? gradeSectionId,
  }) async {
    try {
      final offset = (page - 1) * pageSize;
      final students = await remoteDataSource.getStudentsWithPagination(
        offset: offset,
        limit: pageSize,
        gradeSectionId: gradeSectionId,
      );
      return Right(students.cast<StudentEntity>());
    } catch (e) {
      logger.error('Error fetching paginated students: ${e.toString()}', category: LogCategory.system);
      return Left(ServerFailure('Failed to fetch students: ${e.toString()}'));
    }
  }
}
