create table public.exam_calendar (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  exam_name text not null,
  exam_type text not null default 'monthlyTest'::text,
  month_number integer not null,
  planned_start_date date not null,
  planned_end_date date not null,
  paper_submission_deadline date null,
  display_order integer not null default 1,
  metadata jsonb null,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint exam_calendar_pkey primary key (id),
  constraint exam_calendar_tenant_name_unique unique (tenant_id, exam_name),
  constraint exam_calendar_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
  constraint exam_calendar_dates_check check ((planned_start_date <= planned_end_date)),
  constraint exam_calendar_month_check check (
    (
      (month_number >= 1)
      and (month_number <= 12)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_exam_calendar_tenant_id on public.exam_calendar using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_exam_calendar_month_number on public.exam_calendar using btree (month_number) TABLESPACE pg_default;

create index IF not exists idx_exam_calendar_exam_type on public.exam_calendar using btree (exam_type) TABLESPACE pg_default;

create index IF not exists idx_exam_calendar_tenant_active on public.exam_calendar using btree (tenant_id, is_active) TABLESPACE pg_default;

create trigger set_exam_calendar_updated_at BEFORE
update on exam_calendar for EACH row
execute FUNCTION update_exam_calendar_updated_at ();

create table public.exam_timetable_entries (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  timetable_id uuid not null,
  grade_id uuid not null,
  subject_id uuid not null,
  section text not null,
  exam_date date not null,
  start_time time without time zone not null,
  end_time time without time zone not null,
  duration_minutes integer not null,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint exam_timetable_entries_pkey primary key (id),
  constraint exam_timetable_entries_unique unique (timetable_id, grade_id, subject_id, section),
  constraint exam_timetable_entries_subject_id_fkey foreign KEY (subject_id) references subjects (id) on delete CASCADE,
  constraint exam_timetable_entries_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
  constraint exam_timetable_entries_grade_id_fkey foreign KEY (grade_id) references grades (id) on delete CASCADE,
  constraint exam_timetable_entries_timetable_id_fkey foreign KEY (timetable_id) references exam_timetables (id) on delete CASCADE,
  constraint exam_timetable_entries_duration_check check ((duration_minutes > 0)),
  constraint exam_timetable_entries_time_check check ((start_time < end_time))
) TABLESPACE pg_default;

create index IF not exists idx_exam_timetable_entries_tenant_id on public.exam_timetable_entries using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_exam_timetable_entries_timetable_id on public.exam_timetable_entries using btree (timetable_id) TABLESPACE pg_default;

create index IF not exists idx_exam_timetable_entries_grade_subject on public.exam_timetable_entries using btree (grade_id, subject_id) TABLESPACE pg_default;

create index IF not exists idx_exam_timetable_entries_exam_date on public.exam_timetable_entries using btree (exam_date) TABLESPACE pg_default;

create index IF not exists idx_exam_timetable_entries_timetable_grade_subject on public.exam_timetable_entries using btree (timetable_id, grade_id, subject_id) TABLESPACE pg_default;

create trigger set_exam_timetable_entries_updated_at BEFORE
update on exam_timetable_entries for EACH row
execute FUNCTION update_exam_timetable_entries_updated_at ();

create table public.exam_timetables (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  created_by uuid not null,
  exam_calendar_id uuid null,
  exam_name text not null,
  exam_type text not null default 'monthlyTest'::text,
  exam_number integer null,
  academic_year text not null,
  status text not null default 'draft'::text,
  published_at timestamp with time zone null,
  is_active boolean not null default true,
  metadata jsonb null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint exam_timetables_pkey primary key (id),
  constraint exam_timetables_created_by_fkey foreign KEY (created_by) references profiles (id) on delete RESTRICT,
  constraint exam_timetables_exam_calendar_id_fkey foreign KEY (exam_calendar_id) references exam_calendar (id) on delete set null,
  constraint exam_timetables_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
  constraint exam_timetables_exam_type_check check (
    (
      exam_type = any (
        array[
          'monthlyTest'::text,
          'halfYearlyTest'::text,
          'quarterlyTest'::text,
          'finalExam'::text,
          'dailyTest'::text
        ]
      )
    )
  ),
  constraint exam_timetables_status_check check (
    (
      status = any (
        array[
          'draft'::text,
          'published'::text,
          'completed'::text,
          'cancelled'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_exam_timetables_tenant_id on public.exam_timetables using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_exam_timetables_created_by on public.exam_timetables using btree (created_by) TABLESPACE pg_default;

create index IF not exists idx_exam_timetables_status on public.exam_timetables using btree (status) TABLESPACE pg_default;

create index IF not exists idx_exam_timetables_exam_calendar_id on public.exam_timetables using btree (exam_calendar_id) TABLESPACE pg_default;

create index IF not exists idx_exam_timetables_tenant_status_published on public.exam_timetables using btree (tenant_id, status, published_at desc nulls last) TABLESPACE pg_default;

create index IF not exists idx_exam_timetables_academic_year on public.exam_timetables using btree (academic_year) TABLESPACE pg_default;

create trigger set_exam_timetables_updated_at BEFORE
update on exam_timetables for EACH row
execute FUNCTION update_exam_timetables_updated_at ();

create table public.grade_sections (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  grade_id uuid not null,
  section_name text not null,
  display_order integer not null default 1,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint grade_sections_pkey primary key (id),
  constraint grade_sections_tenant_grade_section_unique unique (tenant_id, grade_id, section_name),
  constraint grade_sections_grade_id_fkey foreign KEY (grade_id) references grades (id) on delete CASCADE,
  constraint grade_sections_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_grade_sections_tenant_grade_active on public.grade_sections using btree (tenant_id, grade_id, is_active) TABLESPACE pg_default;

create index IF not exists idx_grade_sections_tenant_id on public.grade_sections using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_grade_sections_grade_id on public.grade_sections using btree (grade_id) TABLESPACE pg_default;

create trigger set_grade_sections_updated_at BEFORE
update on grade_sections for EACH row
execute FUNCTION update_grade_sections_updated_at ();


create table public.grades (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  grade_number integer not null,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint grades_pkey primary key (id),
  constraint grades_tenant_number_unique unique (tenant_id, grade_number),
  constraint grades_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
  constraint grades_number_check check (
    (
      (grade_number >= 1)
      and (grade_number <= 13)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_grades_tenant_id on public.grades using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_grades_tenant_number on public.grades using btree (tenant_id, grade_number) TABLESPACE pg_default;

create trigger set_grades_updated_at BEFORE
update on grades for EACH row
execute FUNCTION update_updated_at_column ();


create table public.notifications (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  tenant_id uuid not null,
  type text not null,
  title text not null,
  message text not null,
  data jsonb null,
  is_read boolean not null default false,
  created_at timestamp with time zone not null default now(),
  read_at timestamp with time zone null,
  constraint notifications_pkey primary key (id),
  constraint notifications_tenant_fk foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
  constraint notifications_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint notifications_type_check check (
    (
      type = any (
        array[
          'paper_approved'::text,
          'paper_rejected'::text,
          'paper_resubmitted'::text,
          'paper_created'::text,
          'paper_submission_deadline'::text,
          'paper_pending_review'::text,
          'timetable_published'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists notifications_user_id_idx on public.notifications using btree (user_id) TABLESPACE pg_default;

create index IF not exists notifications_tenant_id_idx on public.notifications using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists notifications_is_read_idx on public.notifications using btree (is_read) TABLESPACE pg_default;

create index IF not exists notifications_created_at_idx on public.notifications using btree (created_at desc) TABLESPACE pg_default;

create index IF not exists notifications_user_unread_idx on public.notifications using btree (user_id, is_read) TABLESPACE pg_default
where
  (is_read = false);

  create table public.paper_rejection_history (
    id uuid not null default extensions.uuid_generate_v4 (),
    paper_id uuid not null,
    rejection_reason text not null,
    constraint paper_rejection_history_pkey primary key (id),
    constraint paper_rejection_history_paper_id_fkey foreign KEY (paper_id) references question_papers (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create table public.profiles (
    id uuid not null,
    email text not null,
    full_name text null,
    tenant_id uuid null,
    role text not null default 'user'::text,
    is_active boolean not null default true,
    last_login_at timestamp with time zone null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    constraint profiles_pkey primary key (id),
    constraint profiles_email_key unique (email),
    constraint profiles_id_fkey foreign KEY (id) references auth.users (id) on delete CASCADE,
    constraint profiles_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete set null,
    constraint profiles_role_check check (
      (
        role = any (
          array[
            'admin'::text,
            'teacher'::text,
            'student'::text,
            'user'::text,
            'blocked'::text
          ]
        )
      )
    )
  ) TABLESPACE pg_default;

  create index IF not exists idx_profiles_email on public.profiles using btree (email) TABLESPACE pg_default;

  create index IF not exists idx_profiles_tenant_id on public.profiles using btree (tenant_id) TABLESPACE pg_default;

  create index IF not exists idx_profiles_tenant_role_active on public.profiles using btree (tenant_id, role, is_active) TABLESPACE pg_default;

  create index IF not exists idx_profiles_email_domain on public.profiles using btree (split_part(email, '@'::text, 2)) TABLESPACE pg_default;

  create trigger on_profile_updated_sync_jwt
  after
  update on profiles for EACH row
  execute FUNCTION update_jwt_claims_on_profile_update ();

  create trigger set_profiles_updated_at BEFORE
  update on profiles for EACH row
  execute FUNCTION update_updated_at_column ();

  create table public.question_papers (
    id uuid not null default gen_random_uuid (),
    tenant_id uuid not null,
    user_id uuid not null,
    reviewed_by uuid null,
    subject_id uuid not null,
    grade_id uuid not null,
    academic_year text not null,
    title text not null,
    exam_date date null,
    questions jsonb not null,
    metadata jsonb null,
    status text not null default 'draft'::text,
    rejection_reason text null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    submitted_at timestamp with time zone null,
    reviewed_at timestamp with time zone null,
    paper_sections jsonb not null,
    exam_type character varying(50) not null default 'monthlyTest'::character varying,
    exam_number integer null,
    section text null,
    constraint question_papers_pkey primary key (id),
    constraint question_papers_title_unique unique (
      tenant_id,
      subject_id,
      grade_id,
      academic_year,
      title
    ),
    constraint question_papers_grade_id_fkey foreign KEY (grade_id) references grades (id) on delete RESTRICT,
    constraint question_papers_reviewed_by_fkey foreign KEY (reviewed_by) references profiles (id) on delete set null,
    constraint question_papers_subject_id_fkey foreign KEY (subject_id) references subjects (id) on delete RESTRICT,
    constraint question_papers_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
    constraint question_papers_user_id_fkey foreign KEY (user_id) references profiles (id) on delete CASCADE,
    constraint question_papers_rejection_reason_check check (
      (
        (status <> 'rejected'::text)
        or (rejection_reason is not null)
      )
    ),
    constraint question_papers_questions_size check ((pg_column_size(questions) < 1048576)),
    constraint question_papers_sections_valid check (
      (
        (jsonb_typeof(paper_sections) = 'array'::text)
        and (jsonb_array_length(paper_sections) > 0)
      )
    ),
    constraint question_papers_status_check check (
      (
        status = any (
          array[
            'draft'::text,
            'submitted'::text,
            'approved'::text,
            'rejected'::text
          ]
        )
      )
    )
  ) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_tenant_id on public.question_papers using btree (tenant_id) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_user_id on public.question_papers using btree (user_id) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_reviewed_by on public.question_papers using btree (reviewed_by) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_subject_id on public.question_papers using btree (subject_id) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_grade_id on public.question_papers using btree (grade_id) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_academic_year on public.question_papers using btree (academic_year) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_tenant_status_submitted on public.question_papers using btree (tenant_id, status, submitted_at desc) TABLESPACE pg_default
  where
    (
      status = any (
        array[
          'submitted'::text,
          'approved'::text,
          'rejected'::text
        ]
      )
    );

  create index IF not exists idx_question_papers_user_status_created on public.question_papers using btree (user_id, status, created_at desc) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_tenant_subject_grade_year on public.question_papers using btree (tenant_id, subject_id, grade_id, academic_year) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_pending_review on public.question_papers using btree (tenant_id, submitted_at desc) TABLESPACE pg_default
  where
    (status = 'submitted'::text);

  create index IF not exists idx_question_papers_questions_gin on public.question_papers using gin (questions) TABLESPACE pg_default;

  create unique INDEX IF not exists idx_question_papers_unique_with_section on public.question_papers using btree (
    tenant_id,
    subject_id,
    grade_id,
    academic_year,
    title,
    COALESCE(section, ''::text)
  ) TABLESPACE pg_default
  where
    (status <> 'draft'::text);

  create trigger handle_paper_status BEFORE
  update on question_papers for EACH row
  execute FUNCTION handle_paper_status_change ();

  create trigger set_question_papers_updated_at BEFORE
  update on question_papers for EACH row
  execute FUNCTION update_updated_at_column ();



  create table public.subject_catalog (
    id uuid not null default gen_random_uuid (),
    name text not null,
    description text null,
    min_grade integer not null default 1,
    max_grade integer not null default 12,
    is_active boolean not null default true,
    created_at timestamp with time zone not null default now(),
    constraint subject_catalog_pkey primary key (id),
    constraint subject_catalog_name_key unique (name),
    constraint subject_catalog_grade_range check (
      (
        (min_grade >= 1)
        and (max_grade <= 12)
        and (min_grade <= max_grade)
      )
    )
  ) TABLESPACE pg_default;

  create index IF not exists idx_subject_catalog_active on public.subject_catalog using btree (is_active) TABLESPACE pg_default;

  create index IF not exists idx_subject_catalog_grade_range on public.subject_catalog using btree (min_grade, max_grade) TABLESPACE pg_default;


  create table public.subjects (
    id uuid not null default gen_random_uuid (),
    tenant_id uuid not null,
    catalog_subject_id uuid not null,
    is_active boolean not null default true,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    constraint subjects_pkey primary key (id),
    constraint subjects_tenant_subject_unique unique (tenant_id, catalog_subject_id),
    constraint subjects_catalog_subject_id_fkey foreign KEY (catalog_subject_id) references subject_catalog (id) on delete RESTRICT,
    constraint subjects_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists idx_subjects_tenant_active on public.subjects using btree (tenant_id, is_active) TABLESPACE pg_default;

  create index IF not exists idx_subjects_tenant_id on public.subjects using btree (tenant_id) TABLESPACE pg_default;

  create index IF not exists idx_subjects_catalog_subject_id on public.subjects using btree (catalog_subject_id) TABLESPACE pg_default;

  create trigger set_subjects_updated_at BEFORE
  update on subjects for EACH row
  execute FUNCTION update_updated_at_column ();



  create table public.teacher_grade_assignments (
    id uuid not null default gen_random_uuid (),
    teacher_id uuid not null,
    grade_id uuid not null,
    academic_year text not null,
    is_active boolean not null default true,
    created_at timestamp with time zone not null default now(),
    tenant_id uuid not null,
    constraint teacher_grade_assignments_pkey primary key (id),
    constraint teacher_grade_unique unique (tenant_id, teacher_id, grade_id, academic_year),
    constraint teacher_grade_grade_id_fkey foreign KEY (grade_id) references grades (id) on delete CASCADE,
    constraint teacher_grade_teacher_id_fkey foreign KEY (teacher_id) references profiles (id) on delete CASCADE,
    constraint teacher_grade_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_teacher_id on public.teacher_grade_assignments using btree (teacher_id) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_grade_id on public.teacher_grade_assignments using btree (grade_id) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_academic_year on public.teacher_grade_assignments using btree (academic_year) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_active on public.teacher_grade_assignments using btree (teacher_id, is_active) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_tenant_id on public.teacher_grade_assignments using btree (tenant_id) TABLESPACE pg_default;


  create table public.teacher_patterns (
    id uuid not null default gen_random_uuid (),
    tenant_id uuid not null,
    teacher_id uuid not null,
    subject_id uuid not null,
    name text not null,
    sections jsonb not null,
    total_questions integer not null,
    total_marks integer not null,
    use_count integer null default 0,
    last_used_at timestamp with time zone null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    constraint teacher_patterns_pkey primary key (id),
    constraint teacher_patterns_subject_id_fkey foreign KEY (subject_id) references subjects (id) on delete CASCADE,
    constraint teacher_patterns_teacher_id_fkey foreign KEY (teacher_id) references profiles (id) on delete CASCADE,
    constraint teacher_patterns_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
    constraint teacher_patterns_sections_valid check (
      (
        (jsonb_typeof(sections) = 'array'::text)
        and (jsonb_array_length(sections) > 0)
      )
    ),
    constraint teacher_patterns_questions_positive check ((total_questions > 0)),
    constraint teacher_patterns_marks_positive check ((total_marks > 0))
  ) TABLESPACE pg_default;

  create index IF not exists teacher_patterns_teacher_subject_idx on public.teacher_patterns using btree (
    teacher_id,
    subject_id,
    last_used_at desc nulls last
  ) TABLESPACE pg_default;

  create index IF not exists teacher_patterns_tenant_idx on public.teacher_patterns using btree (tenant_id) TABLESPACE pg_default;

  create trigger teacher_patterns_updated_at_trigger BEFORE
  update on teacher_patterns for EACH row
  execute FUNCTION update_teacher_patterns_updated_at ();


create table public.teacher_subject_assignments (
  id uuid not null default gen_random_uuid (),
  teacher_id uuid not null,
  subject_id uuid not null,
  academic_year text not null,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  tenant_id uuid not null,
  constraint teacher_subject_assignments_pkey primary key (id),
  constraint teacher_subject_unique unique (tenant_id, teacher_id, subject_id, academic_year),
  constraint teacher_subject_subject_id_fkey foreign KEY (subject_id) references subjects (id) on delete CASCADE,
  constraint teacher_subject_teacher_id_fkey foreign KEY (teacher_id) references profiles (id) on delete CASCADE,
  constraint teacher_subject_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_teacher_id on public.teacher_subject_assignments using btree (teacher_id) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_subject_id on public.teacher_subject_assignments using btree (subject_id) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_academic_year on public.teacher_subject_assignments using btree (academic_year) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_active on public.teacher_subject_assignments using btree (teacher_id, is_active) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_tenant_id on public.teacher_subject_assignments using btree (tenant_id) TABLESPACE pg_default;

create table public.teacher_subjects (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  teacher_id uuid not null,
  grade_id uuid not null,
  subject_id uuid not null,
  section text not null,
  academic_year text not null,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint teacher_subjects_pkey primary key (id),
  constraint teacher_subjects_unique unique (
    tenant_id,
    teacher_id,
    grade_id,
    subject_id,
    section,
    academic_year
  ),
  constraint teacher_subjects_grade_id_fkey foreign KEY (grade_id) references grades (id) on delete CASCADE,
  constraint teacher_subjects_subject_id_fkey foreign KEY (subject_id) references subjects (id) on delete CASCADE,
  constraint teacher_subjects_teacher_id_fkey foreign KEY (teacher_id) references profiles (id) on delete CASCADE,
  constraint teacher_subjects_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_teacher_subjects_tenant_id on public.teacher_subjects using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_teacher_subjects_teacher_id on public.teacher_subjects using btree (teacher_id) TABLESPACE pg_default;

create index IF not exists idx_teacher_subjects_grade_subject on public.teacher_subjects using btree (grade_id, subject_id) TABLESPACE pg_default;

create index IF not exists idx_teacher_subjects_teacher_active on public.teacher_subjects using btree (teacher_id, is_active) TABLESPACE pg_default;

create index IF not exists idx_teacher_subjects_academic_year on public.teacher_subjects using btree (academic_year) TABLESPACE pg_default;

create trigger set_teacher_subjects_updated_at BEFORE
update on teacher_subjects for EACH row
execute FUNCTION update_teacher_subjects_updated_at ();


create table public.tenants (
  id uuid not null default gen_random_uuid (),
  name text not null,
  address text null,
  domain text null,
  current_academic_year text not null default '2024-2025'::text,
  is_active boolean not null default true,
  is_initialized boolean not null default false,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint tenants_pkey primary key (id),
  constraint tenants_domain_key unique (domain),
  constraint tenants_domain_not_empty check (
    (
      (domain is null)
      or (
        length(
          TRIM(
            both
            from
              domain
          )
        ) > 0
      )
    )
  ),
  constraint tenants_name_not_empty check (
    (
      length(
        TRIM(
          both
          from
            name
        )
      ) > 0
    )
  ),
  constraint tenants_no_personal_domains check (
    (
      (domain is null)
      or (
        domain <> all (
          array[
            'gmail.com'::text,
            'yahoo.com'::text,
            'outlook.com'::text,
            'hotmail.com'::text
          ]
        )
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_tenants_domain on public.tenants using btree (domain) TABLESPACE pg_default;

create index IF not exists idx_tenants_initialized on public.tenants using btree (is_initialized) TABLESPACE pg_default;

create index IF not exists idx_tenants_active on public.tenants using btree (is_active) TABLESPACE pg_default;

create trigger set_tenants_updated_at BEFORE
update on tenants for EACH row
execute FUNCTION update_updated_at_column ();

