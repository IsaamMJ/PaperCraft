create table public.grades (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  grade_number integer not null,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint grades_pkey primary key (id),
  constraint grades_tenant_number_unique unique (tenant_id, grade_number),
  constraint grades_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
  constraint grades_number_check check (
    (
      (grade_number >= 1)
      and (grade_number <= 13)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_grades_tenant_id on public.grades using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_grades_tenant_number on public.grades using btree (tenant_id, grade_number) TABLESPACE pg_default;

create trigger set_grades_updated_at BEFORE
update on grades for EACH row
execute FUNCTION update_updated_at_column ();

create table public.notifications (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  tenant_id uuid not null,
  type text not null,
  title text not null,
  message text not null,
  data jsonb null,
  is_read boolean not null default false,
  created_at timestamp with time zone not null default now(),
  read_at timestamp with time zone null,
  constraint notifications_pkey primary key (id),
  constraint notifications_tenant_fk foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
  constraint notifications_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE,
  constraint notifications_type_check check (
    (
      type = any (
        array[
          'paper_approved'::text,
          'paper_rejected'::text,
          'paper_resubmitted'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists notifications_user_id_idx on public.notifications using btree (user_id) TABLESPACE pg_default;

create index IF not exists notifications_tenant_id_idx on public.notifications using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists notifications_is_read_idx on public.notifications using btree (is_read) TABLESPACE pg_default;

create index IF not exists notifications_created_at_idx on public.notifications using btree (created_at desc) TABLESPACE pg_default;

create index IF not exists notifications_user_unread_idx on public.notifications using btree (user_id, is_read) TABLESPACE pg_default
where
  (is_read = false);

  create table public.paper_rejection_history (
    id uuid not null default extensions.uuid_generate_v4 (),
    paper_id uuid not null,
    rejection_reason text not null,
    constraint paper_rejection_history_pkey primary key (id),
    constraint paper_rejection_history_paper_id_fkey foreign KEY (paper_id) references question_papers (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create table public.profiles (
    id uuid not null,
    email text not null,
    full_name text null,
    tenant_id uuid null,
    role text not null default 'user'::text,
    is_active boolean not null default true,
    last_login_at timestamp with time zone null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    constraint profiles_pkey primary key (id),
    constraint profiles_email_key unique (email),
    constraint profiles_id_fkey foreign KEY (id) references auth.users (id) on delete CASCADE,
    constraint profiles_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete set null,
    constraint profiles_role_check check (
      (
        role = any (
          array[
            'admin'::text,
            'teacher'::text,
            'student'::text,
            'user'::text,
            'blocked'::text
          ]
        )
      )
    )
  ) TABLESPACE pg_default;

  create index IF not exists idx_profiles_email on public.profiles using btree (email) TABLESPACE pg_default;

  create index IF not exists idx_profiles_tenant_id on public.profiles using btree (tenant_id) TABLESPACE pg_default;

  create index IF not exists idx_profiles_tenant_role_active on public.profiles using btree (tenant_id, role, is_active) TABLESPACE pg_default;

  create index IF not exists idx_profiles_email_domain on public.profiles using btree (split_part(email, '@'::text, 2)) TABLESPACE pg_default;

  create trigger on_profile_updated_sync_jwt
  after
  update on profiles for EACH row
  execute FUNCTION update_jwt_claims_on_profile_update ();

  create trigger set_profiles_updated_at BEFORE
  update on profiles for EACH row
  execute FUNCTION update_updated_at_column ();

  create table public.question_papers (
    id uuid not null default gen_random_uuid (),
    tenant_id uuid not null,
    user_id uuid not null,
    reviewed_by uuid null,
    subject_id uuid not null,
    grade_id uuid not null,
    academic_year text not null,
    title text not null,
    exam_date date null,
    questions jsonb not null,
    metadata jsonb null,
    status text not null default 'draft'::text,
    rejection_reason text null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    submitted_at timestamp with time zone null,
    reviewed_at timestamp with time zone null,
    paper_sections jsonb not null,
    exam_type character varying(50) not null default 'monthlyTest'::character varying,
    exam_number integer null,
    constraint question_papers_pkey primary key (id),
    constraint question_papers_title_unique unique (
      tenant_id,
      subject_id,
      grade_id,
      academic_year,
      title
    ),
    constraint question_papers_grade_id_fkey foreign KEY (grade_id) references grades (id) on delete RESTRICT,
    constraint question_papers_reviewed_by_fkey foreign KEY (reviewed_by) references profiles (id) on delete set null,
    constraint question_papers_subject_id_fkey foreign KEY (subject_id) references subjects (id) on delete RESTRICT,
    constraint question_papers_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
    constraint question_papers_user_id_fkey foreign KEY (user_id) references profiles (id) on delete CASCADE,
    constraint question_papers_rejection_reason_check check (
      (
        (status <> 'rejected'::text)
        or (rejection_reason is not null)
      )
    ),
    constraint question_papers_questions_size check ((pg_column_size(questions) < 1048576)),
    constraint question_papers_sections_valid check (
      (
        (jsonb_typeof(paper_sections) = 'array'::text)
        and (jsonb_array_length(paper_sections) > 0)
      )
    ),
    constraint question_papers_status_check check (
      (
        status = any (
          array[
            'draft'::text,
            'submitted'::text,
            'approved'::text,
            'rejected'::text
          ]
        )
      )
    )
  ) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_tenant_id on public.question_papers using btree (tenant_id) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_user_id on public.question_papers using btree (user_id) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_reviewed_by on public.question_papers using btree (reviewed_by) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_subject_id on public.question_papers using btree (subject_id) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_grade_id on public.question_papers using btree (grade_id) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_academic_year on public.question_papers using btree (academic_year) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_tenant_status_submitted on public.question_papers using btree (tenant_id, status, submitted_at desc) TABLESPACE pg_default
  where
    (
      status = any (
        array[
          'submitted'::text,
          'approved'::text,
          'rejected'::text
        ]
      )
    );

  create index IF not exists idx_question_papers_user_status_created on public.question_papers using btree (user_id, status, created_at desc) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_tenant_subject_grade_year on public.question_papers using btree (tenant_id, subject_id, grade_id, academic_year) TABLESPACE pg_default;

  create index IF not exists idx_question_papers_pending_review on public.question_papers using btree (tenant_id, submitted_at desc) TABLESPACE pg_default
  where
    (status = 'submitted'::text);

  create index IF not exists idx_question_papers_questions_gin on public.question_papers using gin (questions) TABLESPACE pg_default;

  create trigger handle_paper_status BEFORE
  update on question_papers for EACH row
  execute FUNCTION handle_paper_status_change ();

  create trigger set_question_papers_updated_at BEFORE
  update on question_papers for EACH row
  execute FUNCTION update_updated_at_column ();

  create table public.subject_catalog (
    id uuid not null default gen_random_uuid (),
    name text not null,
    description text null,
    min_grade integer not null default 1,
    max_grade integer not null default 12,
    is_active boolean not null default true,
    created_at timestamp with time zone not null default now(),
    constraint subject_catalog_pkey primary key (id),
    constraint subject_catalog_name_key unique (name),
    constraint subject_catalog_grade_range check (
      (
        (min_grade >= 1)
        and (max_grade <= 12)
        and (min_grade <= max_grade)
      )
    )
  ) TABLESPACE pg_default;

  create index IF not exists idx_subject_catalog_active on public.subject_catalog using btree (is_active) TABLESPACE pg_default;

  create index IF not exists idx_subject_catalog_grade_range on public.subject_catalog using btree (min_grade, max_grade) TABLESPACE pg_default;

  create table public.subjects (
    id uuid not null default gen_random_uuid (),
    tenant_id uuid not null,
    catalog_subject_id uuid not null,
    is_active boolean not null default true,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    constraint subjects_pkey primary key (id),
    constraint subjects_tenant_subject_unique unique (tenant_id, catalog_subject_id),
    constraint subjects_catalog_subject_id_fkey foreign KEY (catalog_subject_id) references subject_catalog (id) on delete RESTRICT,
    constraint subjects_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists idx_subjects_tenant_active on public.subjects using btree (tenant_id, is_active) TABLESPACE pg_default;

  create index IF not exists idx_subjects_tenant_id on public.subjects using btree (tenant_id) TABLESPACE pg_default;

  create index IF not exists idx_subjects_catalog_subject_id on public.subjects using btree (catalog_subject_id) TABLESPACE pg_default;

  create trigger set_subjects_updated_at BEFORE
  update on subjects for EACH row
  execute FUNCTION update_updated_at_column ();

  create table public.teacher_grade_assignments (
    id uuid not null default gen_random_uuid (),
    teacher_id uuid not null,
    grade_id uuid not null,
    academic_year text not null,
    is_active boolean not null default true,
    created_at timestamp with time zone not null default now(),
    tenant_id uuid not null,
    constraint teacher_grade_assignments_pkey primary key (id),
    constraint teacher_grade_unique unique (tenant_id, teacher_id, grade_id, academic_year),
    constraint teacher_grade_grade_id_fkey foreign KEY (grade_id) references grades (id) on delete CASCADE,
    constraint teacher_grade_teacher_id_fkey foreign KEY (teacher_id) references profiles (id) on delete CASCADE,
    constraint teacher_grade_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_teacher_id on public.teacher_grade_assignments using btree (teacher_id) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_grade_id on public.teacher_grade_assignments using btree (grade_id) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_academic_year on public.teacher_grade_assignments using btree (academic_year) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_active on public.teacher_grade_assignments using btree (teacher_id, is_active) TABLESPACE pg_default;

  create index IF not exists idx_teacher_grade_tenant_id on public.teacher_grade_assignments using btree (tenant_id) TABLESPACE pg_default;

  create table public.teacher_patterns (
    id uuid not null default gen_random_uuid (),
    tenant_id uuid not null,
    teacher_id uuid not null,
    subject_id uuid not null,
    name text not null,
    sections jsonb not null,
    total_questions integer not null,
    total_marks integer not null,
    use_count integer null default 0,
    last_used_at timestamp with time zone null,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    constraint teacher_patterns_pkey primary key (id),
    constraint teacher_patterns_subject_id_fkey foreign KEY (subject_id) references subjects (id) on delete CASCADE,
    constraint teacher_patterns_teacher_id_fkey foreign KEY (teacher_id) references profiles (id) on delete CASCADE,
    constraint teacher_patterns_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
    constraint teacher_patterns_sections_valid check (
      (
        (jsonb_typeof(sections) = 'array'::text)
        and (jsonb_array_length(sections) > 0)
      )
    ),
    constraint teacher_patterns_questions_positive check ((total_questions > 0)),
    constraint teacher_patterns_marks_positive check ((total_marks > 0))
  ) TABLESPACE pg_default;

  create index IF not exists teacher_patterns_teacher_subject_idx on public.teacher_patterns using btree (
    teacher_id,
    subject_id,
    last_used_at desc nulls last
  ) TABLESPACE pg_default;

  create index IF not exists teacher_patterns_tenant_idx on public.teacher_patterns using btree (tenant_id) TABLESPACE pg_default;

  create trigger teacher_patterns_updated_at_trigger BEFORE
  update on teacher_patterns for EACH row
  execute FUNCTION update_teacher_patterns_updated_at ();

create table public.teacher_subject_assignments (
  id uuid not null default gen_random_uuid (),
  teacher_id uuid not null,
  subject_id uuid not null,
  academic_year text not null,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  tenant_id uuid not null,
  constraint teacher_subject_assignments_pkey primary key (id),
  constraint teacher_subject_unique unique (tenant_id, teacher_id, subject_id, academic_year),
  constraint teacher_subject_subject_id_fkey foreign KEY (subject_id) references subjects (id) on delete CASCADE,
  constraint teacher_subject_teacher_id_fkey foreign KEY (teacher_id) references profiles (id) on delete CASCADE,
  constraint teacher_subject_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_teacher_id on public.teacher_subject_assignments using btree (teacher_id) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_subject_id on public.teacher_subject_assignments using btree (subject_id) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_academic_year on public.teacher_subject_assignments using btree (academic_year) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_active on public.teacher_subject_assignments using btree (teacher_id, is_active) TABLESPACE pg_default;

create index IF not exists idx_teacher_subject_tenant_id on public.teacher_subject_assignments using btree (tenant_id) TABLESPACE pg_default;

create table public.tenants (
  id uuid not null default gen_random_uuid (),
  name text not null,
  address text null,
  domain text null,
  current_academic_year text not null default '2024-2025'::text,
  is_active boolean not null default true,
  is_initialized boolean not null default false,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint tenants_pkey primary key (id),
  constraint tenants_domain_key unique (domain),
  constraint tenants_domain_not_empty check (
    (
      (domain is null)
      or (
        length(
          TRIM(
            both
            from
              domain
          )
        ) > 0
      )
    )
  ),
  constraint tenants_name_not_empty check (
    (
      length(
        TRIM(
          both
          from
            name
        )
      ) > 0
    )
  ),
  constraint tenants_no_personal_domains check (
    (
      (domain is null)
      or (
        domain <> all (
          array[
            'gmail.com'::text,
            'yahoo.com'::text,
            'outlook.com'::text,
            'hotmail.com'::text
          ]
        )
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_tenants_domain on public.tenants using btree (domain) TABLESPACE pg_default;

create index IF not exists idx_tenants_initialized on public.tenants using btree (is_initialized) TABLESPACE pg_default;

create index IF not exists idx_tenants_active on public.tenants using btree (is_active) TABLESPACE pg_default;

create trigger set_tenants_updated_at BEFORE
update on tenants for EACH row
execute FUNCTION update_updated_at_column ();